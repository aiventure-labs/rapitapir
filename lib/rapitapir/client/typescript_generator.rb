# frozen_string_literal: true

require_relative 'generator_base'

module RapiTapir
  module Client
    # TypeScript client generator for RapiTapir APIs
    # Generates strongly-typed TypeScript clients from endpoint definitions
    class TypescriptGenerator < GeneratorBase
      def generate
        [
          generate_header,
          generate_types,
          generate_client_class,
          generate_exports
        ].join("\n\n")
      end

      private

      def generate_header
        <<~TYPESCRIPT
          // Generated by RapiTapir TypeScript Client Generator
          // Package: #{config[:package_name]}
          // Version: #{config[:version]}
          // Base URL: #{config[:base_url]}

          // Response type for all API calls
          export interface ApiResponse<T> {
            data: T;
            status: number;
            headers: Record<string, string>;
          }

          // Error type for API errors
          export interface ApiError {
            message: string;
            status: number;
            details?: any;
          }

          // HTTP client configuration
          export interface ClientConfig {
            baseUrl?: string;
            headers?: Record<string, string>;
            timeout?: number;
          }
        TYPESCRIPT
      end

      def generate_types
        # Generate request/response types for each endpoint
        types = endpoints.map do |endpoint|
          generate_endpoint_types(endpoint)
        end

        return '' if types.empty?

        "// Generated types\n#{types.compact.join("\n\n")}"
      end

      def generate_endpoint_types(endpoint)
        types = []
        method_name = method_name_for_endpoint(endpoint)

        types.concat(generate_request_type(endpoint, method_name))
        types.concat(generate_response_type(endpoint, method_name))

        types.join("\n\n")
      end

      def generate_request_type(endpoint, method_name)
        params = path_parameters(endpoint) + query_parameters(endpoint)
        body = request_body(endpoint)

        return [] unless params.any? || body

        request_props = build_request_properties(endpoint, body)
        return [] unless request_props.any?

        [<<~TYPESCRIPT]
          export interface #{method_name.capitalize}Request {
          #{request_props.join("\n")}
          }
        TYPESCRIPT
      end

      def build_request_properties(endpoint, body)
        props = []

        props.concat(build_path_parameter_properties(endpoint))
        props.concat(build_query_parameter_properties(endpoint))
        props.concat(build_body_properties(body))

        props
      end

      def build_path_parameter_properties(endpoint)
        path_parameters(endpoint).map do |param|
          ts_type = convert_type(param.type, language: :typescript)
          "  #{param.name}: #{ts_type};"
        end
      end

      def build_query_parameter_properties(endpoint)
        query_parameters(endpoint).map do |param|
          ts_type = convert_type(param.type, language: :typescript)
          optional = param.required? ? '' : '?'
          "  #{param.name}#{optional}: #{ts_type};"
        end
      end

      def build_body_properties(body)
        return [] unless body

        ts_type = convert_type(body.type, language: :typescript)
        ["  body: #{ts_type};"]
      end

      def generate_response_type(endpoint, method_name)
        response = response_type(endpoint)
        return [] unless response

        ts_type = convert_type(response, language: :typescript)
        ["export type #{method_name.capitalize}Response = #{ts_type};"]
      end

      def generate_client_class
        methods = endpoints.map { |endpoint| generate_client_method(endpoint) }.compact

        <<~TYPESCRIPT
          export class #{config[:client_name]} {
            private baseUrl: string;
            private headers: Record<string, string>;
            private timeout: number;
          #{'  '}
            constructor(config: ClientConfig = {}) {
              this.baseUrl = config.baseUrl || '#{config[:base_url]}';
              this.headers = config.headers || {};
              this.timeout = config.timeout || 10000;
            }
          #{'  '}
            private async request<T>(
              method: string,
              path: string,
              options: {
                params?: Record<string, any>;
                body?: any;
                headers?: Record<string, string>;
              } = {}
            ): Promise<ApiResponse<T>> {
              const url = new URL(path, this.baseUrl);
          #{'    '}
              // Add query parameters
              if (options.params) {
                Object.entries(options.params).forEach(([key, value]) => {
                  if (value !== undefined && value !== null) {
                    url.searchParams.append(key, String(value));
                  }
                });
              }
          #{'    '}
              const requestHeaders = {
                'Content-Type': 'application/json',
                ...this.headers,
                ...options.headers,
              };
          #{'    '}
              const requestInit: RequestInit = {
                method,
                headers: requestHeaders,
              };
          #{'    '}
              if (options.body) {
                requestInit.body = JSON.stringify(options.body);
              }
          #{'    '}
              try {
                const response = await fetch(url.toString(), requestInit);
          #{'      '}
                const responseHeaders: Record<string, string> = {};
                response.headers.forEach((value, key) => {
                  responseHeaders[key] = value;
                });
          #{'      '}
                let data: T;
                const contentType = response.headers.get('content-type');
                if (contentType && contentType.includes('application/json')) {
                  data = await response.json();
                } else {
                  data = (await response.text()) as unknown as T;
                }
          #{'      '}
                if (!response.ok) {
                  const error: ApiError = {
                    message: `HTTP ${response.status}: ${response.statusText}`,
                    status: response.status,
                    details: data,
                  };
                  throw error;
                }
          #{'      '}
                return {
                  data,
                  status: response.status,
                  headers: responseHeaders,
                };
              } catch (error) {
                if (error && typeof error === 'object' && 'status' in error) {
                  throw error; // Re-throw ApiError
                }
          #{'      '}
                const apiError: ApiError = {
                  message: error instanceof Error ? error.message : 'Unknown error',
                  status: 0,
                  details: error,
                };
                throw apiError;
              }
            }
          #{'  '}
          #{methods.join("\n\n")}
          }
        TYPESCRIPT
      end

      def generate_client_method(endpoint)
        method_name = method_name_for_endpoint(endpoint)
        http_method = endpoint.method.to_s.upcase
        path = endpoint.path

        params = build_method_parameters(endpoint, method_name)
        has_params = has_method_parameters?(endpoint)
        
        method_signature = build_method_signature(method_name, params, has_params, endpoint)
        method_body = build_method_body(method_signature, endpoint, has_params, http_method, path)

        method_body.join("\n")
      end

      def build_method_parameters(endpoint, method_name)
        params = []
        has_params = has_method_parameters?(endpoint)
        params << "request: #{method_name.capitalize}Request" if has_params
        params
      end

      def has_method_parameters?(endpoint)
        path_parameters(endpoint).any? || query_parameters(endpoint).any? || request_body(endpoint)
      end

      def build_method_signature(method_name, params, has_params, endpoint)
        response_type_name = determine_response_type_name(endpoint, method_name)

        if has_params
          "async #{method_name}(#{params.join(', ')}): Promise<ApiResponse<#{response_type_name}>>"
        else
          "async #{method_name}(): Promise<ApiResponse<#{response_type_name}>>"
        end
      end

      def determine_response_type_name(endpoint, method_name)
        if response_type(endpoint)
          "#{method_name.capitalize}Response"
        else
          'void'
        end
      end

      def build_method_body(method_signature, endpoint, has_params, http_method, path)
        method_body = ["  #{method_signature} {"]

        if has_params
          method_body.concat(build_method_body_with_params(endpoint, http_method, path))
        else
          method_body.concat(build_method_body_without_params(endpoint, http_method, path))
        end

        method_body << '  }'
        method_body
      end

      def build_method_body_with_params(endpoint, http_method, path)
        method_name = method_name_for_endpoint(endpoint)
        response_type_name = determine_response_type_name(endpoint, method_name)
        actual_path = build_actual_path(endpoint, path)
        
        body = ["    return this.request<#{response_type_name}>('#{http_method}', #{actual_path}, {"]
        
        request_options = build_request_options(endpoint)
        body << "      #{request_options.join(',')}" if request_options.any?
        body << '    });'
        
        body
      end

      def build_method_body_without_params(endpoint, http_method, path)
        method_name = method_name_for_endpoint(endpoint)
        response_type_name = determine_response_type_name(endpoint, method_name)
        ["    return this.request<#{response_type_name}>('#{http_method}', '#{path}');"]
      end

      def build_actual_path(endpoint, path)
        path_params = path_parameters(endpoint)
        
        if path_params.any?
          "`#{path.gsub(/:(\w+)/, '${request.\1}')}`"
        else
          "'#{path}'"
        end
      end

      def build_request_options(endpoint)
        options = []
        
        query_params_obj = build_query_params_object(endpoint)
        options << "params: #{query_params_obj}" if query_parameters(endpoint).any?
        
        request_body_obj = build_request_body_object(endpoint)
        options << "body: #{request_body_obj}" if request_body(endpoint)
        
        options
      end

      def build_query_params_object(endpoint)
        query_params = query_parameters(endpoint)
        
        if query_params.any?
          param_assignments = query_params.map do |param|
            "#{param.name}: request.#{param.name}"
          end
          "{ #{param_assignments.join(', ')} }"
        else
          'undefined'
        end
      end

      def build_request_body_object(endpoint)
        request_body(endpoint) ? 'request.body' : 'undefined'
      end

      def generate_exports
        <<~TYPESCRIPT
          // Default export
          export default #{config[:client_name]};
        TYPESCRIPT
      end
    end
  end
end
