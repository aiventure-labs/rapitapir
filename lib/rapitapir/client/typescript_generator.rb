# frozen_string_literal: true

require_relative 'generator_base'

module RapiTapir
  module Client
    class TypescriptGenerator < GeneratorBase
      def generate
        [
          generate_header,
          generate_types,
          generate_client_class,
          generate_exports
        ].join("\n\n")
      end

      private

      def generate_header
        <<~TYPESCRIPT
          // Generated by RapiTapir TypeScript Client Generator
          // Package: #{config[:package_name]}
          // Version: #{config[:version]}
          // Base URL: #{config[:base_url]}
          
          // Response type for all API calls
          export interface ApiResponse<T> {
            data: T;
            status: number;
            headers: Record<string, string>;
          }
          
          // Error type for API errors
          export interface ApiError {
            message: string;
            status: number;
            details?: any;
          }
          
          // HTTP client configuration
          export interface ClientConfig {
            baseUrl?: string;
            headers?: Record<string, string>;
            timeout?: number;
          }
        TYPESCRIPT
      end

      def generate_types
        types = []
        
        # Generate request/response types for each endpoint
        endpoints.each do |endpoint|
          types << generate_endpoint_types(endpoint)
        end
        
        return "" if types.empty?
        
        "// Generated types\n" + types.compact.join("\n\n")
      end

      def generate_endpoint_types(endpoint)
        types = []
        method_name = method_name_for_endpoint(endpoint)
        
        # Generate request type if there are parameters
        params = path_parameters(endpoint) + query_parameters(endpoint)
        body = request_body(endpoint)
        
        if params.any? || body
          request_props = []
          
          # Path parameters
          path_parameters(endpoint).each do |param|
            ts_type = convert_type(param.type, language: :typescript)
            request_props << "  #{param.name}: #{ts_type};"
          end
          
          # Query parameters
          query_parameters(endpoint).each do |param|
            ts_type = convert_type(param.type, language: :typescript)
            optional = param.required? ? '' : '?'
            request_props << "  #{param.name}#{optional}: #{ts_type};"
          end
          
          # Request body
          if body
            ts_type = convert_type(body.type, language: :typescript)
            request_props << "  body: #{ts_type};"
          end
          
          if request_props.any?
            types << <<~TYPESCRIPT
              export interface #{method_name.capitalize}Request {
              #{request_props.join("\n")}
              }
            TYPESCRIPT
          end
        end
        
        # Generate response type
        response = response_type(endpoint)
        if response
          ts_type = convert_type(response, language: :typescript)
          types << "export type #{method_name.capitalize}Response = #{ts_type};"
        end
        
        types.join("\n\n")
      end

      def generate_client_class
        methods = endpoints.map { |endpoint| generate_client_method(endpoint) }.compact
        
        <<~TYPESCRIPT
          export class #{config[:client_name]} {
            private baseUrl: string;
            private headers: Record<string, string>;
            private timeout: number;
            
            constructor(config: ClientConfig = {}) {
              this.baseUrl = config.baseUrl || '#{config[:base_url]}';
              this.headers = config.headers || {};
              this.timeout = config.timeout || 10000;
            }
            
            private async request<T>(
              method: string,
              path: string,
              options: {
                params?: Record<string, any>;
                body?: any;
                headers?: Record<string, string>;
              } = {}
            ): Promise<ApiResponse<T>> {
              const url = new URL(path, this.baseUrl);
              
              // Add query parameters
              if (options.params) {
                Object.entries(options.params).forEach(([key, value]) => {
                  if (value !== undefined && value !== null) {
                    url.searchParams.append(key, String(value));
                  }
                });
              }
              
              const requestHeaders = {
                'Content-Type': 'application/json',
                ...this.headers,
                ...options.headers,
              };
              
              const requestInit: RequestInit = {
                method,
                headers: requestHeaders,
              };
              
              if (options.body) {
                requestInit.body = JSON.stringify(options.body);
              }
              
              try {
                const response = await fetch(url.toString(), requestInit);
                
                const responseHeaders: Record<string, string> = {};
                response.headers.forEach((value, key) => {
                  responseHeaders[key] = value;
                });
                
                let data: T;
                const contentType = response.headers.get('content-type');
                if (contentType && contentType.includes('application/json')) {
                  data = await response.json();
                } else {
                  data = (await response.text()) as unknown as T;
                }
                
                if (!response.ok) {
                  const error: ApiError = {
                    message: `HTTP ${response.status}: ${response.statusText}`,
                    status: response.status,
                    details: data,
                  };
                  throw error;
                }
                
                return {
                  data,
                  status: response.status,
                  headers: responseHeaders,
                };
              } catch (error) {
                if (error && typeof error === 'object' && 'status' in error) {
                  throw error; // Re-throw ApiError
                }
                
                const apiError: ApiError = {
                  message: error instanceof Error ? error.message : 'Unknown error',
                  status: 0,
                  details: error,
                };
                throw apiError;
              }
            }
            
          #{methods.join("\n\n")}
          }
        TYPESCRIPT
      end

      def generate_client_method(endpoint)
        method_name = method_name_for_endpoint(endpoint)
        http_method = endpoint.method.to_s.upcase
        path = endpoint.path
        
        # Build method parameters
        params = []
        path_params = path_parameters(endpoint)
        query_params = query_parameters(endpoint)
        body_param = request_body(endpoint)
        
        # Check if we need a request object
        has_params = path_params.any? || query_params.any? || body_param
        
        if has_params
          params << "request: #{method_name.capitalize}Request"
        end
        
        # Build path with parameter substitution
        path_with_params = path.gsub(/:(\w+)/) { "{request.#{$1}}" }
        
        # Build query parameters object
        query_params_obj = if query_params.any?
          param_assignments = query_params.map do |param|
            "#{param.name}: request.#{param.name}"
          end
          "{ #{param_assignments.join(', ')} }"
        else
          'undefined'
        end
        
        # Build request body
        request_body_obj = body_param ? 'request.body' : 'undefined'
        
        # Determine response type
        response_type_name = if response_type(endpoint)
          "#{method_name.capitalize}Response"
        else
          'void'
        end
        
        # Build method signature and body
        method_signature = if has_params
          "async #{method_name}(#{params.join(', ')}): Promise<ApiResponse<#{response_type_name}>>"
        else
          "async #{method_name}(): Promise<ApiResponse<#{response_type_name}>>"
        end
        
        # Build the actual path for the request
        actual_path = if path_params.any?
          path.gsub(/:(\w+)/) { "${request.#{$1}}" }
          "`#{path.gsub(/:(\w+)/, '${request.\1}')}`"
        else
          "'#{path}'"
        end
        
        method_body = []
        method_body << "  #{method_signature} {"
        
        if has_params
          method_body << "    return this.request<#{response_type_name}>('#{http_method}', #{actual_path}, {"
          
          request_options = []
          request_options << "params: #{query_params_obj}" if query_params.any?
          request_options << "body: #{request_body_obj}" if body_param
          
          if request_options.any?
            method_body << "      #{request_options.join(',')}"
          end
          
          method_body << "    });"
        else
          method_body << "    return this.request<#{response_type_name}>('#{http_method}', '#{path}');"
        end
        
        method_body << "  }"
        
        method_body.join("\n")
      end

      def generate_exports
        <<~TYPESCRIPT
          // Default export
          export default #{config[:client_name]};
        TYPESCRIPT
      end
    end
  end
end
