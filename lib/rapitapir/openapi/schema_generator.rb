# frozen_string_literal: true

require 'json'

module RapiTapir
  module OpenAPI
    # OpenAPI schema generator for RapiTapir endpoints
    # Converts RapiTapir endpoint definitions to OpenAPI 3.0 specifications
    class SchemaGenerator
      attr_reader :endpoints, :info, :servers

      def initialize(endpoints: [], info: {}, servers: [])
        @endpoints = endpoints
        @info = default_info.merge(info)
        @servers = servers.empty? ? default_servers : servers
      end

      # Generate complete OpenAPI 3.0 specification
      def generate
        {
          openapi: '3.0.3',
          info: @info,
          servers: @servers,
          paths: generate_paths,
          components: generate_components
        }
      end

      # Generate as JSON string
      def to_json(pretty: true)
        schema = generate
        if pretty
          JSON.pretty_generate(schema)
        else
          JSON.generate(schema)
        end
      end

      # Generate as YAML string
      def to_yaml
        require 'yaml'
        YAML.dump(generate)
      end

      private

      def default_info
        {
          title: 'RapiTapir API',
          version: '1.0.0',
          description: 'API generated by RapiTapir'
        }
      end

      def default_servers
        [
          {
            url: 'http://localhost:4567',
            description: 'Development server'
          }
        ]
      end

      def generate_paths
        paths = {}

        @endpoints.each do |endpoint_data|
          endpoint = endpoint_data.is_a?(Hash) ? endpoint_data[:endpoint] : endpoint_data
          # Convert :id format to {id} format for OpenAPI
          path = convert_path_to_openapi(endpoint.path)
          method = endpoint.method.to_s.downcase

          paths[path] ||= {}
          paths[path][method] = generate_operation(endpoint)
        end

        paths
      end

      def generate_operation(endpoint)
        operation = {
          summary: endpoint.metadata[:summary] || generate_default_summary(endpoint),
          description: endpoint.metadata[:description],
          operationId: generate_operation_id(endpoint),
          tags: endpoint.metadata[:tags]&.any? ? endpoint.metadata[:tags] : [generate_default_tag(endpoint)]
        }

        # Add parameters (path, query, header)
        parameters = generate_parameters(endpoint)
        operation[:parameters] = parameters if parameters.any?

        # Add request body
        request_body = generate_request_body(endpoint)
        operation[:requestBody] = request_body if request_body

        # Add responses
        operation[:responses] = generate_responses(endpoint)

        # Remove nil values
        operation.compact
      end

      def generate_parameters(endpoint)
        parameters = []

        endpoint.inputs.each do |input|
          case input.kind
          when :path
            parameters << {
              name: input.name.to_s,
              in: 'path',
              required: true,
              description: "Path parameter: #{input.name}",
              schema: type_to_schema(input.type)
            }
          when :query
            parameters << {
              name: input.name.to_s,
              in: 'query',
              required: input.required?,
              description: "Query parameter: #{input.name}",
              schema: type_to_schema(input.type)
            }
          when :header
            parameters << {
              name: input.name.to_s,
              in: 'header',
              required: input.required?,
              description: "Header parameter: #{input.name}",
              schema: type_to_schema(input.type)
            }
          end
        end

        parameters
      end

      def generate_request_body(endpoint)
        body_input = endpoint.inputs.find { |input| input.kind == :body }
        return nil unless body_input

        content_type = determine_content_type(body_input)

        {
          description: 'Request body',
          required: body_input.required?,
          content: {
            content_type => {
              schema: type_to_schema(body_input.type)
            }
          }
        }
      end

      def generate_responses(endpoint)
        responses = {}

        # Success responses
        endpoint.outputs.each do |output|
          status_code = determine_status_code(output)
          content_type = determine_output_content_type(output)

          responses[status_code.to_s] = {
            description: 'Successful response',
            content: {
              content_type => {
                schema: type_to_schema(output.type)
              }
            }
          }
        end

        # Error responses
        endpoint.errors.each do |error_entry|
          # Handle both old hash format and new EnhancedError objects
          if error_entry.respond_to?(:status_code)
            # New EnhancedError format
            status_code = error_entry.status_code
            description = error_entry.description || 'Error response'
            schema = type_to_schema(error_entry.type || { error: :string })
          else
            # Old hash format (fallback)
            status_code = error_entry[:code] || 400
            description = error_entry[:description] || 'Error response'
            schema = type_to_schema(error_entry[:output]&.type || { error: :string })
          end

          responses[status_code.to_s] = {
            description: description,
            content: {
              'application/json' => {
                schema: schema
              }
            }
          }
        end

        # Default success response if none specified
        if responses.empty?
          responses['200'] = {
            description: 'Successful response'
          }
        end

        responses
      end

      def generate_components
        {
          schemas: generate_schema_components
        }
      end

      def generate_schema_components
        # For now, return empty. In the future, we can extract common schemas
        {}
      end

      def type_to_schema(type)
        case type
        when RapiTapir::Types::String
          { type: 'string' }
        when RapiTapir::Types::Integer
          { type: 'integer' }
        when RapiTapir::Types::Float
          { type: 'number' }
        when RapiTapir::Types::Boolean
          { type: 'boolean' }
        when RapiTapir::Types::Array
          { type: 'array', items: type_to_schema(type.item_type) }
        when RapiTapir::Types::Hash
          if type.field_types.empty?
            { type: 'object' }
          else
            properties = {}
            required = []

            type.field_types.each do |key, value|
              properties[key.to_s] = type_to_schema(value)
              required << key.to_s unless value.nil?
            end

            schema = { type: 'object', properties: properties }
            schema[:required] = required if required.any?
            schema
          end
        when :integer, Integer
          { type: 'integer' }
        when :number, Float
          { type: 'number' }
        when :boolean
          { type: 'boolean' }
        when :date
          { type: 'string', format: 'date' }
        when :datetime
          { type: 'string', format: 'date-time' }
        when Array
          if type.length == 1
            { type: 'array', items: type_to_schema(type.first) }
          else
            { type: 'array', items: { type: 'string' } }
          end
        when Hash
          if type.empty?
            { type: 'object' }
          else
            properties = {}
            required = []

            type.each do |key, value|
              properties[key.to_s] = type_to_schema(value)
              required << key.to_s unless value.nil?
            end

            schema = { type: 'object', properties: properties }
            schema[:required] = required if required.any?
            schema
          end
        else # Default for unknown types and :string, String
          { type: 'string' }
        end
      end

      def determine_content_type(input)
        case input.type
        when Hash
          # For hash types, default to JSON
          return 'application/json'
        end
        'application/json'
      end

      def determine_output_content_type(output)
        case output.kind
        when :xml
          'application/xml'
        when :html
          'text/html'
        else # Default for :json and unknown formats
          'application/json'
        end
      end

      def determine_status_code(output)
        if output.kind == :status && output.type.is_a?(Integer)
          output.type
        else
          # Default status codes based on output type
          case output.kind
          when :json, :xml
            # JSON and XML responses default to 200
            return 200
          end
          200
        end
      end

      def generate_operation_id(endpoint)
        method = endpoint.method.to_s.downcase
        path_parts = endpoint.path.split('/').reject(&:empty?).map do |part|
          part.start_with?(':') ? part[1..] : part
        end

        "#{method}_#{path_parts.join('_')}"
      end

      def generate_default_summary(endpoint)
        method = endpoint.method.to_s.upcase
        path = endpoint.path
        "#{method} #{path}"
      end

      def generate_default_tag(endpoint)
        # Extract the first path segment as a tag
        first_segment = endpoint.path.split('/').reject(&:empty?).first
        first_segment&.capitalize || 'default'
      end

      def convert_path_to_openapi(path)
        # Convert "/users/:id" to "/users/{id}" for OpenAPI
        path.gsub(/:([a-zA-Z_]\w*)/, '{\1}')
      end
    end
  end
end
