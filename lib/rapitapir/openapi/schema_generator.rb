# frozen_string_literal: true

require 'json'

module RapiTapir
  module OpenAPI
    # OpenAPI schema generator for RapiTapir endpoints
    # Converts RapiTapir endpoint definitions to OpenAPI 3.0 specifications
    class SchemaGenerator
      attr_reader :endpoints, :info, :servers

      def initialize(endpoints: [], info: {}, servers: [])
        @endpoints = endpoints
        @info = default_info.merge(info)
        @servers = servers.empty? ? default_servers : servers
        @components_schemas = {}
      end

      # Generate complete OpenAPI 3.0 specification
      def generate
        {
          openapi: '3.0.3',
          info: @info,
          servers: @servers,
          paths: generate_paths,
          components: generate_components
        }
      end

      # Generate as JSON string
      def to_json(pretty: true)
        schema = generate
        if pretty
          JSON.pretty_generate(schema)
        else
          JSON.generate(schema)
        end
      end

      # Generate as YAML string
      def to_yaml
        require 'yaml'
        YAML.dump(generate)
      end

      private

      def default_info
        {
          title: 'RapiTapir API',
          version: '1.0.0',
          description: 'API generated by RapiTapir'
        }
      end

      def default_servers
        [
          {
            url: 'http://localhost:4567',
            description: 'Development server'
          }
        ]
      end

      def generate_paths
        paths = {}

        @endpoints.each do |endpoint_data|
          endpoint = endpoint_data.is_a?(Hash) ? endpoint_data[:endpoint] : endpoint_data
          # Convert :id format to {id} format for OpenAPI
          path = convert_path_to_openapi(endpoint.path)
          method = endpoint.method.to_s.downcase

          paths[path] ||= {}
          paths[path][method] = generate_operation(endpoint)
        end

        paths
      end

      def generate_operation(endpoint)
        operation = build_base_operation(endpoint)

        add_parameters_to_operation(operation, endpoint)
        add_request_body_to_operation(operation, endpoint)
        add_responses_to_operation(operation, endpoint)

        # Remove nil values
        operation.compact
      end

      def build_base_operation(endpoint)
        {
          summary: endpoint.metadata[:summary] || generate_default_summary(endpoint),
          description: endpoint.metadata[:description],
          operationId: generate_operation_id(endpoint),
          tags: endpoint.metadata[:tags]&.any? ? endpoint.metadata[:tags] : [generate_default_tag(endpoint)]
        }
      end

      def add_parameters_to_operation(operation, endpoint)
        parameters = generate_parameters(endpoint)
        operation[:parameters] = parameters if parameters.any?
      end

      def add_request_body_to_operation(operation, endpoint)
        request_body = generate_request_body(endpoint)
        operation[:requestBody] = request_body if request_body
      end

      def add_responses_to_operation(operation, endpoint)
        operation[:responses] = generate_responses(endpoint)
      end

      def generate_parameters(endpoint)
        parameters = []

        endpoint.inputs.each do |input|
          parameter = build_parameter_for_input(input)
          parameters << parameter if parameter
        end

        parameters
      end

      def build_parameter_for_input(input)
        case input.kind
        when :path
          build_path_parameter(input)
        when :query
          build_query_parameter(input)
        when :header
          build_header_parameter(input)
        end
      end

      def build_path_parameter(input)
        {
          name: input.name.to_s,
          in: 'path',
          required: true,
          description: "Path parameter: #{input.name}",
          schema: type_to_schema(input.type)
        }
      end

      def build_query_parameter(input)
        {
          name: input.name.to_s,
          in: 'query',
          required: input.required?,
          description: "Query parameter: #{input.name}",
          schema: type_to_schema(input.type)
        }
      end

      def build_header_parameter(input)
        {
          name: input.name.to_s,
          in: 'header',
          required: input.required?,
          description: "Header parameter: #{input.name}",
          schema: type_to_schema(input.type)
        }
      end

      def generate_request_body(endpoint)
        body_input = endpoint.inputs.find { |input| input.kind == :body }
        return nil unless body_input

        content_type = determine_content_type(body_input)

        {
          description: 'Request body',
          required: body_input.required?,
          content: {
            content_type => {
              schema: type_to_schema(body_input.type)
            }
          }
        }
      end

      def generate_responses(endpoint)
        responses = {}

        generate_success_responses(endpoint, responses)
        generate_error_responses(endpoint, responses)
        add_default_response_if_needed(responses)

        responses
      end

      def generate_success_responses(endpoint, responses)
        endpoint.outputs.each do |output|
          status_code = determine_status_code(output)
          content_type = determine_output_content_type(output)

          responses[status_code.to_s] = {
            description: 'Successful response',
            content: {
              content_type => {
                schema: type_to_schema(output.type)
              }
            }
          }
        end
      end

      def generate_error_responses(endpoint, responses)
        endpoint.errors.each do |error_entry|
          error_response = build_error_response(error_entry)
          responses[error_response[:status_code].to_s] = error_response[:response]
        end
      end

      def build_error_response(error_entry)
        if error_entry.respond_to?(:status_code)
          build_enhanced_error_response(error_entry)
        else
          build_legacy_error_response(error_entry)
        end
      end

      def build_enhanced_error_response(error_entry)
        status_code = error_entry.status_code
        description = error_entry.description || 'Error response'
        schema = type_to_schema(error_entry.type || { error: :string })

        {
          status_code: status_code,
          response: {
            description: description,
            content: {
              'application/json' => {
                schema: schema
              }
            }
          }
        }
      end

      def build_legacy_error_response(error_entry)
        status_code = error_entry[:code] || 400
        description = error_entry[:description] || 'Error response'
        schema = type_to_schema(error_entry[:output]&.type || { error: :string })

        {
          status_code: status_code,
          response: {
            description: description,
            content: {
              'application/json' => {
                schema: schema
              }
            }
          }
        }
      end

      def add_default_response_if_needed(responses)
        return unless responses.empty?

        responses['200'] = {
          description: 'Successful response'
        }
      end

      def generate_components
        {
          schemas: generate_schema_components
        }
      end

      def generate_schema_components
        # Collected during generation when encountering types with a component_name
        @components_schemas
      end

      def type_to_schema(type)
        # If the type carries a component name, register it and return a $ref
        if type.respond_to?(:metadata)
          name = type.metadata[:component_name]
          if name && !name.to_s.empty?
            add_component_schema(name, schema_payload_for(type))
            return { '$ref' => "#/components/schemas/#{sanitize_component_name(name)}" }
          end
        end

        # If the type knows how to render itself to JSON Schema, use that
        return type.to_json_schema if type.respond_to?(:to_json_schema)

        case type
        when RapiTapir::Types::String, :string, String
          { type: 'string' }
        when RapiTapir::Types::Integer, :integer, Integer
          { type: 'integer' }
        when RapiTapir::Types::Float, :number, Float
          { type: 'number' }
        when RapiTapir::Types::Boolean, :boolean
          { type: 'boolean' }
        else
          generate_complex_type_schema(type)
        end
      end

      def schema_payload_for(type)
        if type.respond_to?(:to_json_schema)
          type.to_json_schema
        else
          generate_complex_type_schema(type)
        end
      end

      def add_component_schema(name, schema)
        key = sanitize_component_name(name)
        @components_schemas[key] ||= deep_stringify_keys(schema)
      end

      def sanitize_component_name(name)
        key = name.to_s.strip
        key = key.gsub(/[^A-Za-z0-9_.-]/, '_')
        key = "Model_#{key}" if key.empty? || key =~ /^\d/
        key
      end

      def deep_stringify_keys(obj)
        case obj
        when Array
          obj.map { |v| deep_stringify_keys(v) }
        when Hash
          obj.each_with_object({}) { |(k, v), h| h[k.to_s] = deep_stringify_keys(v) }
        else
          obj
        end
      end

      def generate_complex_type_schema(type)
        case type
        when RapiTapir::Types::Array
          generate_array_schema(type)
        when RapiTapir::Types::Hash
          generate_hash_schema(type)
        when :date, :datetime
          generate_date_schema(type)
        when Array
          generate_ruby_array_schema(type)
        else # Default for unknown types, :string, String, and Hash
          { type: 'string' }
        end
      end

      def generate_array_schema(type)
        { type: 'array', items: type_to_schema(type.item_type) }
      end

      def generate_hash_schema(type)
        return { type: 'object' } if type.field_types.empty?

        properties = {}
        required = []

        type.field_types.each do |key, value|
          properties[key.to_s] = type_to_schema(value)
          required << key.to_s unless value.nil?
        end

        schema = { type: 'object', properties: properties }
        schema[:required] = required if required.any?
        schema
      end

      def generate_date_schema(type)
        format = type == :date ? 'date' : 'date-time'
        { type: 'string', format: format }
      end

      def generate_ruby_array_schema(type)
        if type.length == 1
          { type: 'array', items: type_to_schema(type.first) }
        else
          { type: 'array', items: { type: 'string' } }
        end
      end

      def determine_content_type(input)
        case input.type
        when Hash
          # For hash types, default to JSON
          return 'application/json'
        end
        'application/json'
      end

      def determine_output_content_type(output)
        case output.kind
        when :xml
          'application/xml'
        when :html
          'text/html'
        else # Default for :json and unknown formats
          'application/json'
        end
      end

      def determine_status_code(output)
        if output.kind == :status && output.type.is_a?(Integer)
          output.type
        else
          # Default status codes based on output type
          case output.kind
          when :json, :xml
            # JSON and XML responses default to 200
            return 200
          end
          200
        end
      end

      def generate_operation_id(endpoint)
        method = endpoint.method.to_s.downcase
        path_parts = endpoint.path.split('/').reject(&:empty?).map do |part|
          part.start_with?(':') ? part[1..] : part
        end

        "#{method}_#{path_parts.join('_')}"
      end

      def generate_default_summary(endpoint)
        method = endpoint.method.to_s.upcase
        path = endpoint.path
        "#{method} #{path}"
      end

      def generate_default_tag(endpoint)
        # Extract the first path segment as a tag
        first_segment = endpoint.path.split('/').reject(&:empty?).first
        first_segment&.capitalize || 'default'
      end

      def convert_path_to_openapi(path)
        # Convert "/users/:id" to "/users/{id}" for OpenAPI
        path.gsub(/:([a-zA-Z_]\w*)/, '{\1}')
      end
    end
  end
end
